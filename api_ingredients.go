/*
spoonacular API

The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.

API version: 1.1
Contact: mail@spoonacular.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// IngredientsApiService IngredientsApi service
type IngredientsApiService service

type ApiAutocompleteIngredientSearchRequest struct {
	ctx context.Context
	ApiService *IngredientsApiService
	query *string
	number *int32
	metaInformation *bool
	intolerances *string
	language *string
}

// The (natural language) search query.
func (r ApiAutocompleteIngredientSearchRequest) Query(query string) ApiAutocompleteIngredientSearchRequest {
	r.query = &query
	return r
}

// The maximum number of items to return (between 1 and 100). Defaults to 10.
func (r ApiAutocompleteIngredientSearchRequest) Number(number int32) ApiAutocompleteIngredientSearchRequest {
	r.number = &number
	return r
}

// Whether to return more meta information about the ingredients.
func (r ApiAutocompleteIngredientSearchRequest) MetaInformation(metaInformation bool) ApiAutocompleteIngredientSearchRequest {
	r.metaInformation = &metaInformation
	return r
}

// A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
func (r ApiAutocompleteIngredientSearchRequest) Intolerances(intolerances string) ApiAutocompleteIngredientSearchRequest {
	r.intolerances = &intolerances
	return r
}

// The language of the input. Either &#39;en&#39; or &#39;de&#39;.
func (r ApiAutocompleteIngredientSearchRequest) Language(language string) ApiAutocompleteIngredientSearchRequest {
	r.language = &language
	return r
}

func (r ApiAutocompleteIngredientSearchRequest) Execute() ([]AutocompleteIngredientSearch200ResponseInner, *http.Response, error) {
	return r.ApiService.AutocompleteIngredientSearchExecute(r)
}

/*
AutocompleteIngredientSearch Autocomplete Ingredient Search

Autocomplete the entry of an ingredient.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAutocompleteIngredientSearchRequest
*/
func (a *IngredientsApiService) AutocompleteIngredientSearch(ctx context.Context) ApiAutocompleteIngredientSearchRequest {
	return ApiAutocompleteIngredientSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AutocompleteIngredientSearch200ResponseInner
func (a *IngredientsApiService) AutocompleteIngredientSearchExecute(r ApiAutocompleteIngredientSearchRequest) ([]AutocompleteIngredientSearch200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AutocompleteIngredientSearch200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngredientsApiService.AutocompleteIngredientSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/ingredients/autocomplete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.number != nil {
		localVarQueryParams.Add("number", parameterToString(*r.number, ""))
	}
	if r.metaInformation != nil {
		localVarQueryParams.Add("metaInformation", parameterToString(*r.metaInformation, ""))
	}
	if r.intolerances != nil {
		localVarQueryParams.Add("intolerances", parameterToString(*r.intolerances, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeIngredientAmountRequest struct {
	ctx context.Context
	ApiService *IngredientsApiService
	id float32
	nutrient *string
	target *float32
	unit *string
}

// The target nutrient. See a list of supported nutrients.
func (r ApiComputeIngredientAmountRequest) Nutrient(nutrient string) ApiComputeIngredientAmountRequest {
	r.nutrient = &nutrient
	return r
}

// The target number of the given nutrient.
func (r ApiComputeIngredientAmountRequest) Target(target float32) ApiComputeIngredientAmountRequest {
	r.target = &target
	return r
}

// The target unit.
func (r ApiComputeIngredientAmountRequest) Unit(unit string) ApiComputeIngredientAmountRequest {
	r.unit = &unit
	return r
}

func (r ApiComputeIngredientAmountRequest) Execute() (*ComputeIngredientAmount200Response, *http.Response, error) {
	return r.ApiService.ComputeIngredientAmountExecute(r)
}

/*
ComputeIngredientAmount Compute Ingredient Amount

Compute the amount you need of a certain ingredient for a certain nutritional goal. For example, how much pineapple do you have to eat to get 10 grams of protein?

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the ingredient you want the amount for.
 @return ApiComputeIngredientAmountRequest
*/
func (a *IngredientsApiService) ComputeIngredientAmount(ctx context.Context, id float32) ApiComputeIngredientAmountRequest {
	return ApiComputeIngredientAmountRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ComputeIngredientAmount200Response
func (a *IngredientsApiService) ComputeIngredientAmountExecute(r ApiComputeIngredientAmountRequest) (*ComputeIngredientAmount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComputeIngredientAmount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngredientsApiService.ComputeIngredientAmount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/ingredients/{id}/amount"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nutrient == nil {
		return localVarReturnValue, nil, reportError("nutrient is required and must be specified")
	}
	if r.target == nil {
		return localVarReturnValue, nil, reportError("target is required and must be specified")
	}

	localVarQueryParams.Add("nutrient", parameterToString(*r.nutrient, ""))
	localVarQueryParams.Add("target", parameterToString(*r.target, ""))
	if r.unit != nil {
		localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIngredientInformationRequest struct {
	ctx context.Context
	ApiService *IngredientsApiService
	id int32
	amount *float32
	unit *string
}

// The amount of this ingredient.
func (r ApiGetIngredientInformationRequest) Amount(amount float32) ApiGetIngredientInformationRequest {
	r.amount = &amount
	return r
}

// The unit for the given amount.
func (r ApiGetIngredientInformationRequest) Unit(unit string) ApiGetIngredientInformationRequest {
	r.unit = &unit
	return r
}

func (r ApiGetIngredientInformationRequest) Execute() (*GetIngredientInformation200Response, *http.Response, error) {
	return r.ApiService.GetIngredientInformationExecute(r)
}

/*
GetIngredientInformation Get Ingredient Information

Use an ingredient id to get all available information about an ingredient, such as its image and supermarket aisle.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The item's id.
 @return ApiGetIngredientInformationRequest
*/
func (a *IngredientsApiService) GetIngredientInformation(ctx context.Context, id int32) ApiGetIngredientInformationRequest {
	return ApiGetIngredientInformationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetIngredientInformation200Response
func (a *IngredientsApiService) GetIngredientInformationExecute(r ApiGetIngredientInformationRequest) (*GetIngredientInformation200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIngredientInformation200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngredientsApiService.GetIngredientInformation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/ingredients/{id}/information"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.amount != nil {
		localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	}
	if r.unit != nil {
		localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIngredientSubstitutesRequest struct {
	ctx context.Context
	ApiService *IngredientsApiService
	ingredientName *string
}

// The name of the ingredient you want to replace.
func (r ApiGetIngredientSubstitutesRequest) IngredientName(ingredientName string) ApiGetIngredientSubstitutesRequest {
	r.ingredientName = &ingredientName
	return r
}

func (r ApiGetIngredientSubstitutesRequest) Execute() (*GetIngredientSubstitutes200Response, *http.Response, error) {
	return r.ApiService.GetIngredientSubstitutesExecute(r)
}

/*
GetIngredientSubstitutes Get Ingredient Substitutes

Search for substitutes for a given ingredient.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIngredientSubstitutesRequest
*/
func (a *IngredientsApiService) GetIngredientSubstitutes(ctx context.Context) ApiGetIngredientSubstitutesRequest {
	return ApiGetIngredientSubstitutesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetIngredientSubstitutes200Response
func (a *IngredientsApiService) GetIngredientSubstitutesExecute(r ApiGetIngredientSubstitutesRequest) (*GetIngredientSubstitutes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIngredientSubstitutes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngredientsApiService.GetIngredientSubstitutes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/ingredients/substitutes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ingredientName == nil {
		return localVarReturnValue, nil, reportError("ingredientName is required and must be specified")
	}

	localVarQueryParams.Add("ingredientName", parameterToString(*r.ingredientName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIngredientSubstitutesByIDRequest struct {
	ctx context.Context
	ApiService *IngredientsApiService
	id int32
}

func (r ApiGetIngredientSubstitutesByIDRequest) Execute() (*GetIngredientSubstitutes200Response, *http.Response, error) {
	return r.ApiService.GetIngredientSubstitutesByIDExecute(r)
}

/*
GetIngredientSubstitutesByID Get Ingredient Substitutes by ID

Search for substitutes for a given ingredient.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The item's id.
 @return ApiGetIngredientSubstitutesByIDRequest
*/
func (a *IngredientsApiService) GetIngredientSubstitutesByID(ctx context.Context, id int32) ApiGetIngredientSubstitutesByIDRequest {
	return ApiGetIngredientSubstitutesByIDRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetIngredientSubstitutes200Response
func (a *IngredientsApiService) GetIngredientSubstitutesByIDExecute(r ApiGetIngredientSubstitutesByIDRequest) (*GetIngredientSubstitutes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIngredientSubstitutes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngredientsApiService.GetIngredientSubstitutesByID")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/ingredients/{id}/substitutes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIngredientSearchRequest struct {
	ctx context.Context
	ApiService *IngredientsApiService
	query *string
	addChildren *bool
	minProteinPercent *float32
	maxProteinPercent *float32
	minFatPercent *float32
	maxFatPercent *float32
	minCarbsPercent *float32
	maxCarbsPercent *float32
	metaInformation *bool
	intolerances *string
	sort *string
	sortDirection *string
	offset *int32
	number *int32
	language *string
}

// The (natural language) search query.
func (r ApiIngredientSearchRequest) Query(query string) ApiIngredientSearchRequest {
	r.query = &query
	return r
}

// Whether to add children of found foods.
func (r ApiIngredientSearchRequest) AddChildren(addChildren bool) ApiIngredientSearchRequest {
	r.addChildren = &addChildren
	return r
}

// The minimum percentage of protein the food must have (between 0 and 100).
func (r ApiIngredientSearchRequest) MinProteinPercent(minProteinPercent float32) ApiIngredientSearchRequest {
	r.minProteinPercent = &minProteinPercent
	return r
}

// The maximum percentage of protein the food can have (between 0 and 100).
func (r ApiIngredientSearchRequest) MaxProteinPercent(maxProteinPercent float32) ApiIngredientSearchRequest {
	r.maxProteinPercent = &maxProteinPercent
	return r
}

// The minimum percentage of fat the food must have (between 0 and 100).
func (r ApiIngredientSearchRequest) MinFatPercent(minFatPercent float32) ApiIngredientSearchRequest {
	r.minFatPercent = &minFatPercent
	return r
}

// The maximum percentage of fat the food can have (between 0 and 100).
func (r ApiIngredientSearchRequest) MaxFatPercent(maxFatPercent float32) ApiIngredientSearchRequest {
	r.maxFatPercent = &maxFatPercent
	return r
}

// The minimum percentage of carbs the food must have (between 0 and 100).
func (r ApiIngredientSearchRequest) MinCarbsPercent(minCarbsPercent float32) ApiIngredientSearchRequest {
	r.minCarbsPercent = &minCarbsPercent
	return r
}

// The maximum percentage of carbs the food can have (between 0 and 100).
func (r ApiIngredientSearchRequest) MaxCarbsPercent(maxCarbsPercent float32) ApiIngredientSearchRequest {
	r.maxCarbsPercent = &maxCarbsPercent
	return r
}

// Whether to return more meta information about the ingredients.
func (r ApiIngredientSearchRequest) MetaInformation(metaInformation bool) ApiIngredientSearchRequest {
	r.metaInformation = &metaInformation
	return r
}

// A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
func (r ApiIngredientSearchRequest) Intolerances(intolerances string) ApiIngredientSearchRequest {
	r.intolerances = &intolerances
	return r
}

// The strategy to sort recipes by. See a full list of supported sorting options.
func (r ApiIngredientSearchRequest) Sort(sort string) ApiIngredientSearchRequest {
	r.sort = &sort
	return r
}

// The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending).
func (r ApiIngredientSearchRequest) SortDirection(sortDirection string) ApiIngredientSearchRequest {
	r.sortDirection = &sortDirection
	return r
}

// The number of results to skip (between 0 and 900).
func (r ApiIngredientSearchRequest) Offset(offset int32) ApiIngredientSearchRequest {
	r.offset = &offset
	return r
}

// The maximum number of items to return (between 1 and 100). Defaults to 10.
func (r ApiIngredientSearchRequest) Number(number int32) ApiIngredientSearchRequest {
	r.number = &number
	return r
}

// The language of the input. Either &#39;en&#39; or &#39;de&#39;.
func (r ApiIngredientSearchRequest) Language(language string) ApiIngredientSearchRequest {
	r.language = &language
	return r
}

func (r ApiIngredientSearchRequest) Execute() (*IngredientSearch200Response, *http.Response, error) {
	return r.ApiService.IngredientSearchExecute(r)
}

/*
IngredientSearch Ingredient Search

Search for simple whole foods (e.g. fruits, vegetables, nuts, grains, meat, fish, dairy etc.).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIngredientSearchRequest
*/
func (a *IngredientsApiService) IngredientSearch(ctx context.Context) ApiIngredientSearchRequest {
	return ApiIngredientSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IngredientSearch200Response
func (a *IngredientsApiService) IngredientSearchExecute(r ApiIngredientSearchRequest) (*IngredientSearch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IngredientSearch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngredientsApiService.IngredientSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/ingredients/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.addChildren != nil {
		localVarQueryParams.Add("addChildren", parameterToString(*r.addChildren, ""))
	}
	if r.minProteinPercent != nil {
		localVarQueryParams.Add("minProteinPercent", parameterToString(*r.minProteinPercent, ""))
	}
	if r.maxProteinPercent != nil {
		localVarQueryParams.Add("maxProteinPercent", parameterToString(*r.maxProteinPercent, ""))
	}
	if r.minFatPercent != nil {
		localVarQueryParams.Add("minFatPercent", parameterToString(*r.minFatPercent, ""))
	}
	if r.maxFatPercent != nil {
		localVarQueryParams.Add("maxFatPercent", parameterToString(*r.maxFatPercent, ""))
	}
	if r.minCarbsPercent != nil {
		localVarQueryParams.Add("minCarbsPercent", parameterToString(*r.minCarbsPercent, ""))
	}
	if r.maxCarbsPercent != nil {
		localVarQueryParams.Add("maxCarbsPercent", parameterToString(*r.maxCarbsPercent, ""))
	}
	if r.metaInformation != nil {
		localVarQueryParams.Add("metaInformation", parameterToString(*r.metaInformation, ""))
	}
	if r.intolerances != nil {
		localVarQueryParams.Add("intolerances", parameterToString(*r.intolerances, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.sortDirection != nil {
		localVarQueryParams.Add("sortDirection", parameterToString(*r.sortDirection, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.number != nil {
		localVarQueryParams.Add("number", parameterToString(*r.number, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiIngredientsByIDImageRequest struct {
	ctx context.Context
	ApiService *IngredientsApiService
	id float32
	measure *string
}

// Whether the the measures should be &#39;us&#39; or &#39;metric&#39;.
func (r ApiIngredientsByIDImageRequest) Measure(measure string) ApiIngredientsByIDImageRequest {
	r.measure = &measure
	return r
}

func (r ApiIngredientsByIDImageRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.IngredientsByIDImageExecute(r)
}

/*
IngredientsByIDImage Ingredients by ID Image

Visualize a recipe's ingredient list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The recipe id.
 @return ApiIngredientsByIDImageRequest
*/
func (a *IngredientsApiService) IngredientsByIDImage(ctx context.Context, id float32) ApiIngredientsByIDImageRequest {
	return ApiIngredientsByIDImageRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *IngredientsApiService) IngredientsByIDImageExecute(r ApiIngredientsByIDImageRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngredientsApiService.IngredientsByIDImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recipes/{id}/ingredientWidget.png"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.measure != nil {
		localVarQueryParams.Add("measure", parameterToString(*r.measure, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/png"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMapIngredientsToGroceryProductsRequest struct {
	ctx context.Context
	ApiService *IngredientsApiService
	mapIngredientsToGroceryProductsRequest *MapIngredientsToGroceryProductsRequest
}

func (r ApiMapIngredientsToGroceryProductsRequest) MapIngredientsToGroceryProductsRequest(mapIngredientsToGroceryProductsRequest MapIngredientsToGroceryProductsRequest) ApiMapIngredientsToGroceryProductsRequest {
	r.mapIngredientsToGroceryProductsRequest = &mapIngredientsToGroceryProductsRequest
	return r
}

func (r ApiMapIngredientsToGroceryProductsRequest) Execute() ([]MapIngredientsToGroceryProducts200ResponseInner, *http.Response, error) {
	return r.ApiService.MapIngredientsToGroceryProductsExecute(r)
}

/*
MapIngredientsToGroceryProducts Map Ingredients to Grocery Products

Map a set of ingredients to products you can buy in the grocery store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMapIngredientsToGroceryProductsRequest
*/
func (a *IngredientsApiService) MapIngredientsToGroceryProducts(ctx context.Context) ApiMapIngredientsToGroceryProductsRequest {
	return ApiMapIngredientsToGroceryProductsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MapIngredientsToGroceryProducts200ResponseInner
func (a *IngredientsApiService) MapIngredientsToGroceryProductsExecute(r ApiMapIngredientsToGroceryProductsRequest) ([]MapIngredientsToGroceryProducts200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MapIngredientsToGroceryProducts200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngredientsApiService.MapIngredientsToGroceryProducts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/ingredients/map"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mapIngredientsToGroceryProductsRequest == nil {
		return localVarReturnValue, nil, reportError("mapIngredientsToGroceryProductsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mapIngredientsToGroceryProductsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVisualizeIngredientsRequest struct {
	ctx context.Context
	ApiService *IngredientsApiService
	contentType *string
	language *string
	accept *string
}

// The content type.
func (r ApiVisualizeIngredientsRequest) ContentType(contentType string) ApiVisualizeIngredientsRequest {
	r.contentType = &contentType
	return r
}

// The language of the input. Either &#39;en&#39; or &#39;de&#39;.
func (r ApiVisualizeIngredientsRequest) Language(language string) ApiVisualizeIngredientsRequest {
	r.language = &language
	return r
}

// Accept header.
func (r ApiVisualizeIngredientsRequest) Accept(accept string) ApiVisualizeIngredientsRequest {
	r.accept = &accept
	return r
}

func (r ApiVisualizeIngredientsRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.VisualizeIngredientsExecute(r)
}

/*
VisualizeIngredients Ingredients Widget

Visualize ingredients of a recipe. You can play around with that endpoint!

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVisualizeIngredientsRequest
*/
func (a *IngredientsApiService) VisualizeIngredients(ctx context.Context) ApiVisualizeIngredientsRequest {
	return ApiVisualizeIngredientsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *IngredientsApiService) VisualizeIngredientsExecute(r ApiVisualizeIngredientsRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IngredientsApiService.VisualizeIngredients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recipes/visualizeIngredients"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentType != nil {
		localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	}
	if r.accept != nil {
		localVarHeaderParams["Accept"] = parameterToString(*r.accept, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
