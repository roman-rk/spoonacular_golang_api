/*
spoonacular API

The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.

API version: 1.1
Contact: mail@spoonacular.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// MealPlanningApiService MealPlanningApi service
type MealPlanningApiService service

type ApiAddMealPlanTemplateRequest struct {
	ctx context.Context
	ApiService *MealPlanningApiService
	username string
	hash *string
	addToMealPlanRequest *AddToMealPlanRequest
}

// The private hash for the username.
func (r ApiAddMealPlanTemplateRequest) Hash(hash string) ApiAddMealPlanTemplateRequest {
	r.hash = &hash
	return r
}

func (r ApiAddMealPlanTemplateRequest) AddToMealPlanRequest(addToMealPlanRequest AddToMealPlanRequest) ApiAddMealPlanTemplateRequest {
	r.addToMealPlanRequest = &addToMealPlanRequest
	return r
}

func (r ApiAddMealPlanTemplateRequest) Execute() (*AddMealPlanTemplate200Response, *http.Response, error) {
	return r.ApiService.AddMealPlanTemplateExecute(r)
}

/*
AddMealPlanTemplate Add Meal Plan Template

Add a meal plan template for a user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The username.
 @return ApiAddMealPlanTemplateRequest
*/
func (a *MealPlanningApiService) AddMealPlanTemplate(ctx context.Context, username string) ApiAddMealPlanTemplateRequest {
	return ApiAddMealPlanTemplateRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return AddMealPlanTemplate200Response
func (a *MealPlanningApiService) AddMealPlanTemplateExecute(r ApiAddMealPlanTemplateRequest) (*AddMealPlanTemplate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AddMealPlanTemplate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MealPlanningApiService.AddMealPlanTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mealplanner/{username}/templates"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hash == nil {
		return localVarReturnValue, nil, reportError("hash is required and must be specified")
	}
	if r.addToMealPlanRequest == nil {
		return localVarReturnValue, nil, reportError("addToMealPlanRequest is required and must be specified")
	}

	localVarQueryParams.Add("hash", parameterToString(*r.hash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{""}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addToMealPlanRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddToMealPlanRequest struct {
	ctx context.Context
	ApiService *MealPlanningApiService
	username string
	hash *string
	addToMealPlanRequest *AddToMealPlanRequest
}

// The private hash for the username.
func (r ApiAddToMealPlanRequest) Hash(hash string) ApiAddToMealPlanRequest {
	r.hash = &hash
	return r
}

func (r ApiAddToMealPlanRequest) AddToMealPlanRequest(addToMealPlanRequest AddToMealPlanRequest) ApiAddToMealPlanRequest {
	r.addToMealPlanRequest = &addToMealPlanRequest
	return r
}

func (r ApiAddToMealPlanRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AddToMealPlanExecute(r)
}

/*
AddToMealPlan Add to Meal Plan

Add an item to the user's meal plan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The username.
 @return ApiAddToMealPlanRequest
*/
func (a *MealPlanningApiService) AddToMealPlan(ctx context.Context, username string) ApiAddToMealPlanRequest {
	return ApiAddToMealPlanRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MealPlanningApiService) AddToMealPlanExecute(r ApiAddToMealPlanRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MealPlanningApiService.AddToMealPlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mealplanner/{username}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hash == nil {
		return localVarReturnValue, nil, reportError("hash is required and must be specified")
	}
	if r.addToMealPlanRequest == nil {
		return localVarReturnValue, nil, reportError("addToMealPlanRequest is required and must be specified")
	}

	localVarQueryParams.Add("hash", parameterToString(*r.hash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addToMealPlanRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddToShoppingListRequest struct {
	ctx context.Context
	ApiService *MealPlanningApiService
	username string
	hash *string
	addToMealPlanRequest *AddToMealPlanRequest
}

// The private hash for the username.
func (r ApiAddToShoppingListRequest) Hash(hash string) ApiAddToShoppingListRequest {
	r.hash = &hash
	return r
}

func (r ApiAddToShoppingListRequest) AddToMealPlanRequest(addToMealPlanRequest AddToMealPlanRequest) ApiAddToShoppingListRequest {
	r.addToMealPlanRequest = &addToMealPlanRequest
	return r
}

func (r ApiAddToShoppingListRequest) Execute() (*GenerateShoppingList200Response, *http.Response, error) {
	return r.ApiService.AddToShoppingListExecute(r)
}

/*
AddToShoppingList Add to Shopping List

Add an item to the current shopping list of a user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The username.
 @return ApiAddToShoppingListRequest
*/
func (a *MealPlanningApiService) AddToShoppingList(ctx context.Context, username string) ApiAddToShoppingListRequest {
	return ApiAddToShoppingListRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return GenerateShoppingList200Response
func (a *MealPlanningApiService) AddToShoppingListExecute(r ApiAddToShoppingListRequest) (*GenerateShoppingList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenerateShoppingList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MealPlanningApiService.AddToShoppingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mealplanner/{username}/shopping-list/items"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hash == nil {
		return localVarReturnValue, nil, reportError("hash is required and must be specified")
	}
	if r.addToMealPlanRequest == nil {
		return localVarReturnValue, nil, reportError("addToMealPlanRequest is required and must be specified")
	}

	localVarQueryParams.Add("hash", parameterToString(*r.hash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addToMealPlanRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClearMealPlanDayRequest struct {
	ctx context.Context
	ApiService *MealPlanningApiService
	username string
	date string
	hash *string
	clearMealPlanDayRequest *ClearMealPlanDayRequest
}

// The private hash for the username.
func (r ApiClearMealPlanDayRequest) Hash(hash string) ApiClearMealPlanDayRequest {
	r.hash = &hash
	return r
}

func (r ApiClearMealPlanDayRequest) ClearMealPlanDayRequest(clearMealPlanDayRequest ClearMealPlanDayRequest) ApiClearMealPlanDayRequest {
	r.clearMealPlanDayRequest = &clearMealPlanDayRequest
	return r
}

func (r ApiClearMealPlanDayRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ClearMealPlanDayExecute(r)
}

/*
ClearMealPlanDay Clear Meal Plan Day

Delete all planned items from the user's meal plan for a specific day.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The username.
 @param date The date in the format yyyy-mm-dd.
 @return ApiClearMealPlanDayRequest
*/
func (a *MealPlanningApiService) ClearMealPlanDay(ctx context.Context, username string, date string) ApiClearMealPlanDayRequest {
	return ApiClearMealPlanDayRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
		date: date,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MealPlanningApiService) ClearMealPlanDayExecute(r ApiClearMealPlanDayRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MealPlanningApiService.ClearMealPlanDay")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mealplanner/{username}/day/{date}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"date"+"}", url.PathEscape(parameterToString(r.date, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hash == nil {
		return localVarReturnValue, nil, reportError("hash is required and must be specified")
	}
	if r.clearMealPlanDayRequest == nil {
		return localVarReturnValue, nil, reportError("clearMealPlanDayRequest is required and must be specified")
	}

	localVarQueryParams.Add("hash", parameterToString(*r.hash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{""}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clearMealPlanDayRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectUserRequest struct {
	ctx context.Context
	ApiService *MealPlanningApiService
	body *map[string]interface{}
}

func (r ApiConnectUserRequest) Body(body map[string]interface{}) ApiConnectUserRequest {
	r.body = &body
	return r
}

func (r ApiConnectUserRequest) Execute() (*ConnectUser200Response, *http.Response, error) {
	return r.ApiService.ConnectUserExecute(r)
}

/*
ConnectUser Connect User

In order to call user-specific endpoints, you need to connect your app's users to spoonacular users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConnectUserRequest
*/
func (a *MealPlanningApiService) ConnectUser(ctx context.Context) ApiConnectUserRequest {
	return ApiConnectUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectUser200Response
func (a *MealPlanningApiService) ConnectUserExecute(r ApiConnectUserRequest) (*ConnectUser200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectUser200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MealPlanningApiService.ConnectUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/connect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFromMealPlanRequest struct {
	ctx context.Context
	ApiService *MealPlanningApiService
	username string
	id float32
	hash *string
	deleteFromMealPlanRequest *DeleteFromMealPlanRequest
}

// The private hash for the username.
func (r ApiDeleteFromMealPlanRequest) Hash(hash string) ApiDeleteFromMealPlanRequest {
	r.hash = &hash
	return r
}

func (r ApiDeleteFromMealPlanRequest) DeleteFromMealPlanRequest(deleteFromMealPlanRequest DeleteFromMealPlanRequest) ApiDeleteFromMealPlanRequest {
	r.deleteFromMealPlanRequest = &deleteFromMealPlanRequest
	return r
}

func (r ApiDeleteFromMealPlanRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteFromMealPlanExecute(r)
}

/*
DeleteFromMealPlan Delete from Meal Plan

Delete an item from the user's meal plan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The username.
 @param id The shopping list item id.
 @return ApiDeleteFromMealPlanRequest
*/
func (a *MealPlanningApiService) DeleteFromMealPlan(ctx context.Context, username string, id float32) ApiDeleteFromMealPlanRequest {
	return ApiDeleteFromMealPlanRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MealPlanningApiService) DeleteFromMealPlanExecute(r ApiDeleteFromMealPlanRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MealPlanningApiService.DeleteFromMealPlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mealplanner/{username}/items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hash == nil {
		return localVarReturnValue, nil, reportError("hash is required and must be specified")
	}
	if r.deleteFromMealPlanRequest == nil {
		return localVarReturnValue, nil, reportError("deleteFromMealPlanRequest is required and must be specified")
	}

	localVarQueryParams.Add("hash", parameterToString(*r.hash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{""}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteFromMealPlanRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFromShoppingListRequest struct {
	ctx context.Context
	ApiService *MealPlanningApiService
	username string
	id int32
	hash *string
	deleteFromMealPlanRequest *DeleteFromMealPlanRequest
}

// The private hash for the username.
func (r ApiDeleteFromShoppingListRequest) Hash(hash string) ApiDeleteFromShoppingListRequest {
	r.hash = &hash
	return r
}

func (r ApiDeleteFromShoppingListRequest) DeleteFromMealPlanRequest(deleteFromMealPlanRequest DeleteFromMealPlanRequest) ApiDeleteFromShoppingListRequest {
	r.deleteFromMealPlanRequest = &deleteFromMealPlanRequest
	return r
}

func (r ApiDeleteFromShoppingListRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteFromShoppingListExecute(r)
}

/*
DeleteFromShoppingList Delete from Shopping List

Delete an item from the current shopping list of the user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The username.
 @param id The item's id.
 @return ApiDeleteFromShoppingListRequest
*/
func (a *MealPlanningApiService) DeleteFromShoppingList(ctx context.Context, username string, id int32) ApiDeleteFromShoppingListRequest {
	return ApiDeleteFromShoppingListRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MealPlanningApiService) DeleteFromShoppingListExecute(r ApiDeleteFromShoppingListRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MealPlanningApiService.DeleteFromShoppingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mealplanner/{username}/shopping-list/items/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hash == nil {
		return localVarReturnValue, nil, reportError("hash is required and must be specified")
	}
	if r.deleteFromMealPlanRequest == nil {
		return localVarReturnValue, nil, reportError("deleteFromMealPlanRequest is required and must be specified")
	}

	localVarQueryParams.Add("hash", parameterToString(*r.hash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{""}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteFromMealPlanRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMealPlanTemplateRequest struct {
	ctx context.Context
	ApiService *MealPlanningApiService
	username string
	id int32
	hash *string
	deleteFromMealPlanRequest *DeleteFromMealPlanRequest
}

// The private hash for the username.
func (r ApiDeleteMealPlanTemplateRequest) Hash(hash string) ApiDeleteMealPlanTemplateRequest {
	r.hash = &hash
	return r
}

func (r ApiDeleteMealPlanTemplateRequest) DeleteFromMealPlanRequest(deleteFromMealPlanRequest DeleteFromMealPlanRequest) ApiDeleteMealPlanTemplateRequest {
	r.deleteFromMealPlanRequest = &deleteFromMealPlanRequest
	return r
}

func (r ApiDeleteMealPlanTemplateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteMealPlanTemplateExecute(r)
}

/*
DeleteMealPlanTemplate Delete Meal Plan Template

Delete a meal plan template for a user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The username.
 @param id The item's id.
 @return ApiDeleteMealPlanTemplateRequest
*/
func (a *MealPlanningApiService) DeleteMealPlanTemplate(ctx context.Context, username string, id int32) ApiDeleteMealPlanTemplateRequest {
	return ApiDeleteMealPlanTemplateRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MealPlanningApiService) DeleteMealPlanTemplateExecute(r ApiDeleteMealPlanTemplateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MealPlanningApiService.DeleteMealPlanTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mealplanner/{username}/templates/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hash == nil {
		return localVarReturnValue, nil, reportError("hash is required and must be specified")
	}
	if r.deleteFromMealPlanRequest == nil {
		return localVarReturnValue, nil, reportError("deleteFromMealPlanRequest is required and must be specified")
	}

	localVarQueryParams.Add("hash", parameterToString(*r.hash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{""}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteFromMealPlanRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateMealPlanRequest struct {
	ctx context.Context
	ApiService *MealPlanningApiService
	timeFrame *string
	targetCalories *float32
	diet *string
	exclude *string
}

// Either for one \&quot;day\&quot; or an entire \&quot;week\&quot;.
func (r ApiGenerateMealPlanRequest) TimeFrame(timeFrame string) ApiGenerateMealPlanRequest {
	r.timeFrame = &timeFrame
	return r
}

// What is the caloric target for one day? The meal plan generator will try to get as close as possible to that goal.
func (r ApiGenerateMealPlanRequest) TargetCalories(targetCalories float32) ApiGenerateMealPlanRequest {
	r.targetCalories = &targetCalories
	return r
}

// Enter a diet that the meal plan has to adhere to. See a full list of supported diets.
func (r ApiGenerateMealPlanRequest) Diet(diet string) ApiGenerateMealPlanRequest {
	r.diet = &diet
	return r
}

// A comma-separated list of allergens or ingredients that must be excluded.
func (r ApiGenerateMealPlanRequest) Exclude(exclude string) ApiGenerateMealPlanRequest {
	r.exclude = &exclude
	return r
}

func (r ApiGenerateMealPlanRequest) Execute() (*GenerateMealPlan200Response, *http.Response, error) {
	return r.ApiService.GenerateMealPlanExecute(r)
}

/*
GenerateMealPlan Generate Meal Plan

Generate a meal plan with three meals per day (breakfast, lunch, and dinner).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateMealPlanRequest
*/
func (a *MealPlanningApiService) GenerateMealPlan(ctx context.Context) ApiGenerateMealPlanRequest {
	return ApiGenerateMealPlanRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GenerateMealPlan200Response
func (a *MealPlanningApiService) GenerateMealPlanExecute(r ApiGenerateMealPlanRequest) (*GenerateMealPlan200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenerateMealPlan200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MealPlanningApiService.GenerateMealPlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mealplanner/generate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeFrame != nil {
		localVarQueryParams.Add("timeFrame", parameterToString(*r.timeFrame, ""))
	}
	if r.targetCalories != nil {
		localVarQueryParams.Add("targetCalories", parameterToString(*r.targetCalories, ""))
	}
	if r.diet != nil {
		localVarQueryParams.Add("diet", parameterToString(*r.diet, ""))
	}
	if r.exclude != nil {
		localVarQueryParams.Add("exclude", parameterToString(*r.exclude, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateShoppingListRequest struct {
	ctx context.Context
	ApiService *MealPlanningApiService
	username string
	startDate string
	endDate string
	hash *string
	generateShoppingListRequest *GenerateShoppingListRequest
}

// The private hash for the username.
func (r ApiGenerateShoppingListRequest) Hash(hash string) ApiGenerateShoppingListRequest {
	r.hash = &hash
	return r
}

func (r ApiGenerateShoppingListRequest) GenerateShoppingListRequest(generateShoppingListRequest GenerateShoppingListRequest) ApiGenerateShoppingListRequest {
	r.generateShoppingListRequest = &generateShoppingListRequest
	return r
}

func (r ApiGenerateShoppingListRequest) Execute() (*GenerateShoppingList200Response, *http.Response, error) {
	return r.ApiService.GenerateShoppingListExecute(r)
}

/*
GenerateShoppingList Generate Shopping List

Generate the shopping list for a user from the meal planner in a given time frame.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The username.
 @param startDate The start date in the format yyyy-mm-dd.
 @param endDate The end date in the format yyyy-mm-dd.
 @return ApiGenerateShoppingListRequest
*/
func (a *MealPlanningApiService) GenerateShoppingList(ctx context.Context, username string, startDate string, endDate string) ApiGenerateShoppingListRequest {
	return ApiGenerateShoppingListRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
		startDate: startDate,
		endDate: endDate,
	}
}

// Execute executes the request
//  @return GenerateShoppingList200Response
func (a *MealPlanningApiService) GenerateShoppingListExecute(r ApiGenerateShoppingListRequest) (*GenerateShoppingList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenerateShoppingList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MealPlanningApiService.GenerateShoppingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mealplanner/{username}/shopping-list/{start-date}/{end-date}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"start-date"+"}", url.PathEscape(parameterToString(r.startDate, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"end-date"+"}", url.PathEscape(parameterToString(r.endDate, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hash == nil {
		return localVarReturnValue, nil, reportError("hash is required and must be specified")
	}
	if r.generateShoppingListRequest == nil {
		return localVarReturnValue, nil, reportError("generateShoppingListRequest is required and must be specified")
	}

	localVarQueryParams.Add("hash", parameterToString(*r.hash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{""}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.generateShoppingListRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMealPlanTemplateRequest struct {
	ctx context.Context
	ApiService *MealPlanningApiService
	username string
	id int32
	hash *string
}

// The private hash for the username.
func (r ApiGetMealPlanTemplateRequest) Hash(hash string) ApiGetMealPlanTemplateRequest {
	r.hash = &hash
	return r
}

func (r ApiGetMealPlanTemplateRequest) Execute() (*GetMealPlanTemplate200Response, *http.Response, error) {
	return r.ApiService.GetMealPlanTemplateExecute(r)
}

/*
GetMealPlanTemplate Get Meal Plan Template

Get information about a meal plan template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The username.
 @param id The item's id.
 @return ApiGetMealPlanTemplateRequest
*/
func (a *MealPlanningApiService) GetMealPlanTemplate(ctx context.Context, username string, id int32) ApiGetMealPlanTemplateRequest {
	return ApiGetMealPlanTemplateRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
		id: id,
	}
}

// Execute executes the request
//  @return GetMealPlanTemplate200Response
func (a *MealPlanningApiService) GetMealPlanTemplateExecute(r ApiGetMealPlanTemplateRequest) (*GetMealPlanTemplate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMealPlanTemplate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MealPlanningApiService.GetMealPlanTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mealplanner/{username}/templates/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hash == nil {
		return localVarReturnValue, nil, reportError("hash is required and must be specified")
	}

	localVarQueryParams.Add("hash", parameterToString(*r.hash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMealPlanTemplatesRequest struct {
	ctx context.Context
	ApiService *MealPlanningApiService
	username string
	hash *string
}

// The private hash for the username.
func (r ApiGetMealPlanTemplatesRequest) Hash(hash string) ApiGetMealPlanTemplatesRequest {
	r.hash = &hash
	return r
}

func (r ApiGetMealPlanTemplatesRequest) Execute() (*GetMealPlanTemplates200Response, *http.Response, error) {
	return r.ApiService.GetMealPlanTemplatesExecute(r)
}

/*
GetMealPlanTemplates Get Meal Plan Templates

Get meal plan templates from user or public ones.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The username.
 @return ApiGetMealPlanTemplatesRequest
*/
func (a *MealPlanningApiService) GetMealPlanTemplates(ctx context.Context, username string) ApiGetMealPlanTemplatesRequest {
	return ApiGetMealPlanTemplatesRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return GetMealPlanTemplates200Response
func (a *MealPlanningApiService) GetMealPlanTemplatesExecute(r ApiGetMealPlanTemplatesRequest) (*GetMealPlanTemplates200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMealPlanTemplates200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MealPlanningApiService.GetMealPlanTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mealplanner/{username}/templates"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hash == nil {
		return localVarReturnValue, nil, reportError("hash is required and must be specified")
	}

	localVarQueryParams.Add("hash", parameterToString(*r.hash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMealPlanWeekRequest struct {
	ctx context.Context
	ApiService *MealPlanningApiService
	username string
	startDate string
	hash *string
}

// The private hash for the username.
func (r ApiGetMealPlanWeekRequest) Hash(hash string) ApiGetMealPlanWeekRequest {
	r.hash = &hash
	return r
}

func (r ApiGetMealPlanWeekRequest) Execute() (*GetMealPlanWeek200Response, *http.Response, error) {
	return r.ApiService.GetMealPlanWeekExecute(r)
}

/*
GetMealPlanWeek Get Meal Plan Week

Retrieve a meal planned week for the given user. The username must be a spoonacular user and the hash must the the user's hash that can be found in his/her account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The username.
 @param startDate The start date of the meal planned week in the format yyyy-mm-dd.
 @return ApiGetMealPlanWeekRequest
*/
func (a *MealPlanningApiService) GetMealPlanWeek(ctx context.Context, username string, startDate string) ApiGetMealPlanWeekRequest {
	return ApiGetMealPlanWeekRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
		startDate: startDate,
	}
}

// Execute executes the request
//  @return GetMealPlanWeek200Response
func (a *MealPlanningApiService) GetMealPlanWeekExecute(r ApiGetMealPlanWeekRequest) (*GetMealPlanWeek200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMealPlanWeek200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MealPlanningApiService.GetMealPlanWeek")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mealplanner/{username}/week/{start-date}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"start-date"+"}", url.PathEscape(parameterToString(r.startDate, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hash == nil {
		return localVarReturnValue, nil, reportError("hash is required and must be specified")
	}

	localVarQueryParams.Add("hash", parameterToString(*r.hash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShoppingListRequest struct {
	ctx context.Context
	ApiService *MealPlanningApiService
	username string
	hash *string
}

// The private hash for the username.
func (r ApiGetShoppingListRequest) Hash(hash string) ApiGetShoppingListRequest {
	r.hash = &hash
	return r
}

func (r ApiGetShoppingListRequest) Execute() (*GetShoppingList200Response, *http.Response, error) {
	return r.ApiService.GetShoppingListExecute(r)
}

/*
GetShoppingList Get Shopping List

Get the current shopping list for the given user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username The username.
 @return ApiGetShoppingListRequest
*/
func (a *MealPlanningApiService) GetShoppingList(ctx context.Context, username string) ApiGetShoppingListRequest {
	return ApiGetShoppingListRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return GetShoppingList200Response
func (a *MealPlanningApiService) GetShoppingListExecute(r ApiGetShoppingListRequest) (*GetShoppingList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetShoppingList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MealPlanningApiService.GetShoppingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mealplanner/{username}/shopping-list"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterToString(r.username, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hash == nil {
		return localVarReturnValue, nil, reportError("hash is required and must be specified")
	}

	localVarQueryParams.Add("hash", parameterToString(*r.hash, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
