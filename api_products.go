/*
spoonacular API

The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.

API version: 1.1
Contact: mail@spoonacular.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ProductsApiService ProductsApi service
type ProductsApiService service

type ApiAutocompleteProductSearchRequest struct {
	ctx context.Context
	ApiService *ProductsApiService
	query *string
	number *int32
}

// The (partial) search query.
func (r ApiAutocompleteProductSearchRequest) Query(query string) ApiAutocompleteProductSearchRequest {
	r.query = &query
	return r
}

// The number of results to return (between 1 and 25).
func (r ApiAutocompleteProductSearchRequest) Number(number int32) ApiAutocompleteProductSearchRequest {
	r.number = &number
	return r
}

func (r ApiAutocompleteProductSearchRequest) Execute() (*AutocompleteProductSearch200Response, *http.Response, error) {
	return r.ApiService.AutocompleteProductSearchExecute(r)
}

/*
AutocompleteProductSearch Autocomplete Product Search

Generate suggestions for grocery products based on a (partial) query. The matches will be found by looking in the title only.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAutocompleteProductSearchRequest
*/
func (a *ProductsApiService) AutocompleteProductSearch(ctx context.Context) ApiAutocompleteProductSearchRequest {
	return ApiAutocompleteProductSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AutocompleteProductSearch200Response
func (a *ProductsApiService) AutocompleteProductSearchExecute(r ApiAutocompleteProductSearchRequest) (*AutocompleteProductSearch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutocompleteProductSearch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsApiService.AutocompleteProductSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/products/suggest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	if r.number != nil {
		localVarQueryParams.Add("number", parameterToString(*r.number, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClassifyGroceryProductRequest struct {
	ctx context.Context
	ApiService *ProductsApiService
	classifyGroceryProductRequest *ClassifyGroceryProductRequest
	locale *string
}

func (r ApiClassifyGroceryProductRequest) ClassifyGroceryProductRequest(classifyGroceryProductRequest ClassifyGroceryProductRequest) ApiClassifyGroceryProductRequest {
	r.classifyGroceryProductRequest = &classifyGroceryProductRequest
	return r
}

// The display name of the returned category, supported is en_US (for American English) and en_GB (for British English).
func (r ApiClassifyGroceryProductRequest) Locale(locale string) ApiClassifyGroceryProductRequest {
	r.locale = &locale
	return r
}

func (r ApiClassifyGroceryProductRequest) Execute() (*ClassifyGroceryProduct200Response, *http.Response, error) {
	return r.ApiService.ClassifyGroceryProductExecute(r)
}

/*
ClassifyGroceryProduct Classify Grocery Product

This endpoint allows you to match a packaged food to a basic category, e.g. a specific brand of milk to the category milk.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClassifyGroceryProductRequest
*/
func (a *ProductsApiService) ClassifyGroceryProduct(ctx context.Context) ApiClassifyGroceryProductRequest {
	return ApiClassifyGroceryProductRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClassifyGroceryProduct200Response
func (a *ProductsApiService) ClassifyGroceryProductExecute(r ApiClassifyGroceryProductRequest) (*ClassifyGroceryProduct200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClassifyGroceryProduct200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsApiService.ClassifyGroceryProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/products/classify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.classifyGroceryProductRequest == nil {
		return localVarReturnValue, nil, reportError("classifyGroceryProductRequest is required and must be specified")
	}

	if r.locale != nil {
		localVarQueryParams.Add("locale", parameterToString(*r.locale, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.classifyGroceryProductRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClassifyGroceryProductBulkRequest struct {
	ctx context.Context
	ApiService *ProductsApiService
	classifyGroceryProductBulkRequestInner *[]ClassifyGroceryProductBulkRequestInner
	locale *string
}

func (r ApiClassifyGroceryProductBulkRequest) ClassifyGroceryProductBulkRequestInner(classifyGroceryProductBulkRequestInner []ClassifyGroceryProductBulkRequestInner) ApiClassifyGroceryProductBulkRequest {
	r.classifyGroceryProductBulkRequestInner = &classifyGroceryProductBulkRequestInner
	return r
}

// The display name of the returned category, supported is en_US (for American English) and en_GB (for British English).
func (r ApiClassifyGroceryProductBulkRequest) Locale(locale string) ApiClassifyGroceryProductBulkRequest {
	r.locale = &locale
	return r
}

func (r ApiClassifyGroceryProductBulkRequest) Execute() ([]ClassifyGroceryProductBulk200ResponseInner, *http.Response, error) {
	return r.ApiService.ClassifyGroceryProductBulkExecute(r)
}

/*
ClassifyGroceryProductBulk Classify Grocery Product Bulk

Provide a set of product jsons, get back classified products.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClassifyGroceryProductBulkRequest
*/
func (a *ProductsApiService) ClassifyGroceryProductBulk(ctx context.Context) ApiClassifyGroceryProductBulkRequest {
	return ApiClassifyGroceryProductBulkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ClassifyGroceryProductBulk200ResponseInner
func (a *ProductsApiService) ClassifyGroceryProductBulkExecute(r ApiClassifyGroceryProductBulkRequest) ([]ClassifyGroceryProductBulk200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ClassifyGroceryProductBulk200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsApiService.ClassifyGroceryProductBulk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/products/classifyBatch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.classifyGroceryProductBulkRequestInner == nil {
		return localVarReturnValue, nil, reportError("classifyGroceryProductBulkRequestInner is required and must be specified")
	}
	if len(*r.classifyGroceryProductBulkRequestInner) < 0 {
		return localVarReturnValue, nil, reportError("classifyGroceryProductBulkRequestInner must have at least 0 elements")
	}

	if r.locale != nil {
		localVarQueryParams.Add("locale", parameterToString(*r.locale, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.classifyGroceryProductBulkRequestInner
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetComparableProductsRequest struct {
	ctx context.Context
	ApiService *ProductsApiService
	upc float32
}

func (r ApiGetComparableProductsRequest) Execute() (*GetComparableProducts200Response, *http.Response, error) {
	return r.ApiService.GetComparableProductsExecute(r)
}

/*
GetComparableProducts Get Comparable Products

Find comparable products to the given one.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param upc The UPC of the product for which you want to find comparable products.
 @return ApiGetComparableProductsRequest
*/
func (a *ProductsApiService) GetComparableProducts(ctx context.Context, upc float32) ApiGetComparableProductsRequest {
	return ApiGetComparableProductsRequest{
		ApiService: a,
		ctx: ctx,
		upc: upc,
	}
}

// Execute executes the request
//  @return GetComparableProducts200Response
func (a *ProductsApiService) GetComparableProductsExecute(r ApiGetComparableProductsRequest) (*GetComparableProducts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetComparableProducts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsApiService.GetComparableProducts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/products/upc/{upc}/comparable"
	localVarPath = strings.Replace(localVarPath, "{"+"upc"+"}", url.PathEscape(parameterToString(r.upc, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProductInformationRequest struct {
	ctx context.Context
	ApiService *ProductsApiService
	id int32
}

func (r ApiGetProductInformationRequest) Execute() (*GetProductInformation200Response, *http.Response, error) {
	return r.ApiService.GetProductInformationExecute(r)
}

/*
GetProductInformation Get Product Information

Use a product id to get full information about a product, such as ingredients, nutrition, etc. The nutritional information is per serving.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The item's id.
 @return ApiGetProductInformationRequest
*/
func (a *ProductsApiService) GetProductInformation(ctx context.Context, id int32) ApiGetProductInformationRequest {
	return ApiGetProductInformationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetProductInformation200Response
func (a *ProductsApiService) GetProductInformationExecute(r ApiGetProductInformationRequest) (*GetProductInformation200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProductInformation200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsApiService.GetProductInformation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/products/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductNutritionByIDImageRequest struct {
	ctx context.Context
	ApiService *ProductsApiService
	id float32
}

func (r ApiProductNutritionByIDImageRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ProductNutritionByIDImageExecute(r)
}

/*
ProductNutritionByIDImage Product Nutrition by ID Image

Visualize a product's nutritional information as an image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the product.
 @return ApiProductNutritionByIDImageRequest
*/
func (a *ProductsApiService) ProductNutritionByIDImage(ctx context.Context, id float32) ApiProductNutritionByIDImageRequest {
	return ApiProductNutritionByIDImageRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProductsApiService) ProductNutritionByIDImageExecute(r ApiProductNutritionByIDImageRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsApiService.ProductNutritionByIDImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/products/{id}/nutritionWidget.png"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/png"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductNutritionLabelImageRequest struct {
	ctx context.Context
	ApiService *ProductsApiService
	id float32
	showOptionalNutrients *bool
	showZeroValues *bool
	showIngredients *bool
}

// Whether to show optional nutrients.
func (r ApiProductNutritionLabelImageRequest) ShowOptionalNutrients(showOptionalNutrients bool) ApiProductNutritionLabelImageRequest {
	r.showOptionalNutrients = &showOptionalNutrients
	return r
}

// Whether to show zero values.
func (r ApiProductNutritionLabelImageRequest) ShowZeroValues(showZeroValues bool) ApiProductNutritionLabelImageRequest {
	r.showZeroValues = &showZeroValues
	return r
}

// Whether to show a list of ingredients.
func (r ApiProductNutritionLabelImageRequest) ShowIngredients(showIngredients bool) ApiProductNutritionLabelImageRequest {
	r.showIngredients = &showIngredients
	return r
}

func (r ApiProductNutritionLabelImageRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ProductNutritionLabelImageExecute(r)
}

/*
ProductNutritionLabelImage Product Nutrition Label Image

Get a product's nutrition label as an image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The product id.
 @return ApiProductNutritionLabelImageRequest
*/
func (a *ProductsApiService) ProductNutritionLabelImage(ctx context.Context, id float32) ApiProductNutritionLabelImageRequest {
	return ApiProductNutritionLabelImageRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProductsApiService) ProductNutritionLabelImageExecute(r ApiProductNutritionLabelImageRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsApiService.ProductNutritionLabelImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/products/{id}/nutritionLabel.png"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showOptionalNutrients != nil {
		localVarQueryParams.Add("showOptionalNutrients", parameterToString(*r.showOptionalNutrients, ""))
	}
	if r.showZeroValues != nil {
		localVarQueryParams.Add("showZeroValues", parameterToString(*r.showZeroValues, ""))
	}
	if r.showIngredients != nil {
		localVarQueryParams.Add("showIngredients", parameterToString(*r.showIngredients, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/png"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductNutritionLabelWidgetRequest struct {
	ctx context.Context
	ApiService *ProductsApiService
	id float32
	defaultCss *bool
	showOptionalNutrients *bool
	showZeroValues *bool
	showIngredients *bool
}

// Whether the default CSS should be added to the response.
func (r ApiProductNutritionLabelWidgetRequest) DefaultCss(defaultCss bool) ApiProductNutritionLabelWidgetRequest {
	r.defaultCss = &defaultCss
	return r
}

// Whether to show optional nutrients.
func (r ApiProductNutritionLabelWidgetRequest) ShowOptionalNutrients(showOptionalNutrients bool) ApiProductNutritionLabelWidgetRequest {
	r.showOptionalNutrients = &showOptionalNutrients
	return r
}

// Whether to show zero values.
func (r ApiProductNutritionLabelWidgetRequest) ShowZeroValues(showZeroValues bool) ApiProductNutritionLabelWidgetRequest {
	r.showZeroValues = &showZeroValues
	return r
}

// Whether to show a list of ingredients.
func (r ApiProductNutritionLabelWidgetRequest) ShowIngredients(showIngredients bool) ApiProductNutritionLabelWidgetRequest {
	r.showIngredients = &showIngredients
	return r
}

func (r ApiProductNutritionLabelWidgetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ProductNutritionLabelWidgetExecute(r)
}

/*
ProductNutritionLabelWidget Product Nutrition Label Widget

Get a product's nutrition label as an HTML widget.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The product id.
 @return ApiProductNutritionLabelWidgetRequest
*/
func (a *ProductsApiService) ProductNutritionLabelWidget(ctx context.Context, id float32) ApiProductNutritionLabelWidgetRequest {
	return ApiProductNutritionLabelWidgetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return string
func (a *ProductsApiService) ProductNutritionLabelWidgetExecute(r ApiProductNutritionLabelWidgetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsApiService.ProductNutritionLabelWidget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/products/{id}/nutritionLabel"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.defaultCss != nil {
		localVarQueryParams.Add("defaultCss", parameterToString(*r.defaultCss, ""))
	}
	if r.showOptionalNutrients != nil {
		localVarQueryParams.Add("showOptionalNutrients", parameterToString(*r.showOptionalNutrients, ""))
	}
	if r.showZeroValues != nil {
		localVarQueryParams.Add("showZeroValues", parameterToString(*r.showZeroValues, ""))
	}
	if r.showIngredients != nil {
		localVarQueryParams.Add("showIngredients", parameterToString(*r.showIngredients, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchGroceryProductsRequest struct {
	ctx context.Context
	ApiService *ProductsApiService
	query *string
	minCalories *float32
	maxCalories *float32
	minCarbs *float32
	maxCarbs *float32
	minProtein *float32
	maxProtein *float32
	minFat *float32
	maxFat *float32
	addProductInformation *bool
	offset *int32
	number *int32
}

// The (natural language) search query.
func (r ApiSearchGroceryProductsRequest) Query(query string) ApiSearchGroceryProductsRequest {
	r.query = &query
	return r
}

// The minimum amount of calories the product must have.
func (r ApiSearchGroceryProductsRequest) MinCalories(minCalories float32) ApiSearchGroceryProductsRequest {
	r.minCalories = &minCalories
	return r
}

// The maximum amount of calories the product can have.
func (r ApiSearchGroceryProductsRequest) MaxCalories(maxCalories float32) ApiSearchGroceryProductsRequest {
	r.maxCalories = &maxCalories
	return r
}

// The minimum amount of carbohydrates in grams the product must have.
func (r ApiSearchGroceryProductsRequest) MinCarbs(minCarbs float32) ApiSearchGroceryProductsRequest {
	r.minCarbs = &minCarbs
	return r
}

// The maximum amount of carbohydrates in grams the product can have.
func (r ApiSearchGroceryProductsRequest) MaxCarbs(maxCarbs float32) ApiSearchGroceryProductsRequest {
	r.maxCarbs = &maxCarbs
	return r
}

// The minimum amount of protein in grams the product must have.
func (r ApiSearchGroceryProductsRequest) MinProtein(minProtein float32) ApiSearchGroceryProductsRequest {
	r.minProtein = &minProtein
	return r
}

// The maximum amount of protein in grams the product can have.
func (r ApiSearchGroceryProductsRequest) MaxProtein(maxProtein float32) ApiSearchGroceryProductsRequest {
	r.maxProtein = &maxProtein
	return r
}

// The minimum amount of fat in grams the product must have.
func (r ApiSearchGroceryProductsRequest) MinFat(minFat float32) ApiSearchGroceryProductsRequest {
	r.minFat = &minFat
	return r
}

// The maximum amount of fat in grams the product can have.
func (r ApiSearchGroceryProductsRequest) MaxFat(maxFat float32) ApiSearchGroceryProductsRequest {
	r.maxFat = &maxFat
	return r
}

// If set to true, you get more information about the products returned.
func (r ApiSearchGroceryProductsRequest) AddProductInformation(addProductInformation bool) ApiSearchGroceryProductsRequest {
	r.addProductInformation = &addProductInformation
	return r
}

// The number of results to skip (between 0 and 900).
func (r ApiSearchGroceryProductsRequest) Offset(offset int32) ApiSearchGroceryProductsRequest {
	r.offset = &offset
	return r
}

// The maximum number of items to return (between 1 and 100). Defaults to 10.
func (r ApiSearchGroceryProductsRequest) Number(number int32) ApiSearchGroceryProductsRequest {
	r.number = &number
	return r
}

func (r ApiSearchGroceryProductsRequest) Execute() (*SearchGroceryProducts200Response, *http.Response, error) {
	return r.ApiService.SearchGroceryProductsExecute(r)
}

/*
SearchGroceryProducts Search Grocery Products

Search packaged food products, such as frozen pizza or Greek yogurt.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchGroceryProductsRequest
*/
func (a *ProductsApiService) SearchGroceryProducts(ctx context.Context) ApiSearchGroceryProductsRequest {
	return ApiSearchGroceryProductsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchGroceryProducts200Response
func (a *ProductsApiService) SearchGroceryProductsExecute(r ApiSearchGroceryProductsRequest) (*SearchGroceryProducts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchGroceryProducts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsApiService.SearchGroceryProducts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/products/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.minCalories != nil {
		localVarQueryParams.Add("minCalories", parameterToString(*r.minCalories, ""))
	}
	if r.maxCalories != nil {
		localVarQueryParams.Add("maxCalories", parameterToString(*r.maxCalories, ""))
	}
	if r.minCarbs != nil {
		localVarQueryParams.Add("minCarbs", parameterToString(*r.minCarbs, ""))
	}
	if r.maxCarbs != nil {
		localVarQueryParams.Add("maxCarbs", parameterToString(*r.maxCarbs, ""))
	}
	if r.minProtein != nil {
		localVarQueryParams.Add("minProtein", parameterToString(*r.minProtein, ""))
	}
	if r.maxProtein != nil {
		localVarQueryParams.Add("maxProtein", parameterToString(*r.maxProtein, ""))
	}
	if r.minFat != nil {
		localVarQueryParams.Add("minFat", parameterToString(*r.minFat, ""))
	}
	if r.maxFat != nil {
		localVarQueryParams.Add("maxFat", parameterToString(*r.maxFat, ""))
	}
	if r.addProductInformation != nil {
		localVarQueryParams.Add("addProductInformation", parameterToString(*r.addProductInformation, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.number != nil {
		localVarQueryParams.Add("number", parameterToString(*r.number, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchGroceryProductsByUPCRequest struct {
	ctx context.Context
	ApiService *ProductsApiService
	upc float32
}

func (r ApiSearchGroceryProductsByUPCRequest) Execute() (*SearchGroceryProductsByUPC200Response, *http.Response, error) {
	return r.ApiService.SearchGroceryProductsByUPCExecute(r)
}

/*
SearchGroceryProductsByUPC Search Grocery Products by UPC

Get information about a packaged food using its UPC.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param upc The product's UPC.
 @return ApiSearchGroceryProductsByUPCRequest
*/
func (a *ProductsApiService) SearchGroceryProductsByUPC(ctx context.Context, upc float32) ApiSearchGroceryProductsByUPCRequest {
	return ApiSearchGroceryProductsByUPCRequest{
		ApiService: a,
		ctx: ctx,
		upc: upc,
	}
}

// Execute executes the request
//  @return SearchGroceryProductsByUPC200Response
func (a *ProductsApiService) SearchGroceryProductsByUPCExecute(r ApiSearchGroceryProductsByUPCRequest) (*SearchGroceryProductsByUPC200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchGroceryProductsByUPC200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsApiService.SearchGroceryProductsByUPC")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/products/upc/{upc}"
	localVarPath = strings.Replace(localVarPath, "{"+"upc"+"}", url.PathEscape(parameterToString(r.upc, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVisualizeProductNutritionByIDRequest struct {
	ctx context.Context
	ApiService *ProductsApiService
	id int32
	defaultCss *bool
	accept *string
}

// Whether the default CSS should be added to the response.
func (r ApiVisualizeProductNutritionByIDRequest) DefaultCss(defaultCss bool) ApiVisualizeProductNutritionByIDRequest {
	r.defaultCss = &defaultCss
	return r
}

// Accept header.
func (r ApiVisualizeProductNutritionByIDRequest) Accept(accept string) ApiVisualizeProductNutritionByIDRequest {
	r.accept = &accept
	return r
}

func (r ApiVisualizeProductNutritionByIDRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.VisualizeProductNutritionByIDExecute(r)
}

/*
VisualizeProductNutritionByID Product Nutrition by ID Widget

Visualize a product's nutritional information as HTML including CSS.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The item's id.
 @return ApiVisualizeProductNutritionByIDRequest
*/
func (a *ProductsApiService) VisualizeProductNutritionByID(ctx context.Context, id int32) ApiVisualizeProductNutritionByIDRequest {
	return ApiVisualizeProductNutritionByIDRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return string
func (a *ProductsApiService) VisualizeProductNutritionByIDExecute(r ApiVisualizeProductNutritionByIDRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsApiService.VisualizeProductNutritionByID")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/food/products/{id}/nutritionWidget"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.defaultCss != nil {
		localVarQueryParams.Add("defaultCss", parameterToString(*r.defaultCss, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		localVarHeaderParams["Accept"] = parameterToString(*r.accept, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyScheme"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
